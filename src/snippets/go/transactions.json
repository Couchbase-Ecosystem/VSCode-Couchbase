{
    "Transaction Example": {
        "prefix": ["@cbtran"],
        "body": ["import (","    \"errors\"","    \"fmt\"","    \"log\"","    \"time\"","","    \"github.com/couchbase/gocb/v2\"",")","cluster, err := gocb.Connect(","    \"${1:connectionString}\",","    gocb.ClusterOptions{","        Username: \"${2:username}\",","        Password: \"${3:password}\",","    })","if err != nil {","    panic(err)","}","","// get a bucket reference","bucket := cluster.Bucket(\"${4:bucketName}\")","","// We wait until the bucket is definitely connected and setup.","err = bucket.WaitUntilReady(5*time.Second, nil)","if err != nil {","    panic(err)","}","","// get a user-defined collection reference","scope := bucket.Scope(\"${5:scopeName}\")","collection := scope.Collection(\"${6:collectionName}\")","_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {","    // Getting documents:","    _, err = ctx.Get(collection, \"${7:document-key}\")","    // Use err != nil && !errors.Is(err, gocb.ErrDocumentNotFound) if the document may or may not exist","    if err != nil {","        return err","    }","","    // There is no commit call, by not returning an error the transaction will automatically commit","    return nil","}, nil)","var ambigErr gocb.TransactionCommitAmbiguousError","if errors.As(err, &ambigErr) {","    log.Println(\"Transaction possibly committed\")","","    log.Printf(\"%+v\", ambigErr)","    return","}","var failedErr gocb.TransactionFailedError","if errors.As(err, &failedErr) {","    log.Println(\"Transaction did not reach commit point\")","","    log.Printf(\"%+v\", failedErr)","    return","}","if err != nil {","    panic(err)","}"],
        "description": "Example code that shows connecting to a cluster and running a transaction on it."
    },
    "Insert Transaction": {
        "prefix": ["@cbtranins"],
        "body": ["_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {","    // Inserting a doc:","    _, err := ctx.Insert(${1:collection}, \"${2:document-key}\", ${3:document})","    if err != nil {","        return err","    }","","    // There is no commit call, by not returning an error the transaction will automatically commit","    return nil","}, nil)","var ambigErr gocb.TransactionCommitAmbiguousError","if errors.As(err, &ambigErr) {","    log.Println(\"Transaction possibly committed\")","","    log.Printf(\"%+v\", ambigErr)","    return","}","var failedErr gocb.TransactionFailedError","if errors.As(err, &failedErr) {","    log.Println(\"Transaction did not reach commit point\")","","    log.Printf(\"%+v\", failedErr)","    return","}","if err != nil {","    panic(err)","}"],
        "description": "Perform an insertion transaction"
    },
    "Get Transaction": {
        "prefix": ["@cbtranget"],
        "body": ["_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {","    // Getting documents:","    _, err = ctx.Get(${1:collection}, \"${2:document-key}\")","    // Use err != nil && !errors.Is(err, gocb.ErrDocumentNotFound) if the document may or may not exist","    if err != nil {","        return err","    }","","    // There is no commit call, by not returning an error the transaction will automatically commit","    return nil","}, nil)","var ambigErr gocb.TransactionCommitAmbiguousError","if errors.As(err, &ambigErr) {","    log.Println(\"Transaction possibly committed\")","","    log.Printf(\"%+v\", ambigErr)","    return","}","var failedErr gocb.TransactionFailedError","if errors.As(err, &failedErr) {","    log.Println(\"Transaction did not reach commit point\")","","    log.Printf(\"%+v\", failedErr)","    return","}","if err != nil {","    panic(err)","}"],
        "description": "Perform a get transaction"
    },
    "Replace Transaction": {
        "prefix": ["@cbtranrep"],
        "body": ["_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {","    // Replacing a doc:","    doc, err := ctx.Get(${1:collection}, \"${2:document-key}\")","    if err != nil {","        return err","    }","    _, err = ctx.Replace(doc, ${3:document})","    if err != nil {","        return err","    }","","    // There is no commit call, by not returning an error the transaction will automatically commit","    return nil","}, nil)","var ambigErr gocb.TransactionCommitAmbiguousError","if errors.As(err, &ambigErr) {","    log.Println(\"Transaction possibly committed\")","","    log.Printf(\"%+v\", ambigErr)","    return","}","var failedErr gocb.TransactionFailedError","if errors.As(err, &failedErr) {","    log.Println(\"Transaction did not reach commit point\")","","    log.Printf(\"%+v\", failedErr)","    return","}","if err != nil {","    panic(err)","}"],
        "description": "Perform a replace transaction"
    },
    "Remove Transaction": {
        "prefix": ["@cbtranrem"],
        "body": ["_, err := cluster.Transactions().Run(func(ctx *gocb.TransactionAttemptContext) error {","    // Removing a doc:","    doc, err := ctx.Get(${1:collection}, \"${2:document-key}\")","    if err != nil {","        return err","    }","","    err = ctx.Remove(doc)","    if err != nil {","        return err","    }","","    // There is no commit call, by not returning an error the transaction will automatically commit","    return nil","}, nil)","var ambigErr gocb.TransactionCommitAmbiguousError","if errors.As(err, &ambigErr) {","    log.Println(\"Transaction possibly committed\")","","    log.Printf(\"%+v\", ambigErr)","    return","}","var failedErr gocb.TransactionFailedError","if errors.As(err, &failedErr) {","    log.Println(\"Transaction did not reach commit point\")","","    log.Printf(\"%+v\", failedErr)","    return","}","if err != nil {","    panic(err)","}"],
        "description": "Perform a remove transaction"
    },
    "Transaction Import": {
        "prefix": ["@cbtranimp"],
        "body": ["import (","    \"errors\"","    \"fmt\"","    \"log\"","    \"time\"","","    \"github.com/couchbase/gocb/v2\"",")"],
        "description": "Import all necessary transaction namespaces."
    }
}